---
title: mysql体系结构和存储引擎
tags:
  - 搭建博客
  - 前端
date: 2021-11-05 13:26:10
abbrlink: 80oue
---
frm 表结构
插件式表存储引擎
实例（数据库后台进程/线程和一个共享内存区 ）
和数据库（frm myi myd ibd）

启动实例会读取配置文件，根据配置文件参数启动数据库实例

存储引擎基于表 而不是数据库
oltp 在线事务处理

MVCC获得高并发性  实现4种隔离级别

插入缓冲（性能）  二次写（可靠性）  自适应哈希索引  预读

没有定义表主键 6字节ROWID  作为主键

myisam  全文索引   olap  在线分析处理   myisampack用哈夫曼算法压缩   4G  256T   全文索引

NDB集群存储引擎   高可用  数据全放在内存中  查询速度不行

Memory(heap)  数据放在内存   临时表  哈希索引  表锁 不支持TEXT,BLOB 

Archive 只支持insert,select   存储归档数据，如日志   行锁实现高并发操作
show engines

连接数据库操作 连接进程和数据库实例通信   权限表user

Innodb  高性能 高可用 高可扩展存储引擎

INnodb存储引擎后台线程7个  4个IO 1个master（4个循环） 1个锁监控 1个错误监控线程

内存（缓冲池  重做日志缓冲池  内存池）

Innodb plugin

Innodb存储引擎文件
重做日志文件  表空间文件  ibd  由段，区(64个连续页  1MB)，页*（16kb)组成

面向行 


聚集索引  非聚集索引

一致性非锁定读3
for update 加X锁
lock in share mode 加S锁

begin

start transaction 

行锁算法
记录锁
间隙锁
next-key

undo段位于共享表空间

事务控制语句
begin
start tarnsaction
commit
rollback

隔离级别越低  事务请求锁越少，保持锁时间越短

分布式事务   XA
多个资源管理器  一个事务管理器  一个应用程序

set autocommit=0  设置事务不自动提交


高性能mysql
changebuffer
redo log数据页更改   prepare  commit   checkpoint
binlog  sql语句
MVCC   解决幻读
每一行数据中额外保存两个隐藏的列
插入或上次更新该行的事务ID(删除也被认为是一次更新，只不过在代表删除的更新操作中，行中的特殊位被设置为将其标记为已删除。这个事务ID可以认为是数据行的修改版本号。)

回滚指针(指向undo log中用于事务回滚的日志记录)。


幻读就是事务执行过程中，在查询一个范围的数据时，有新的数据插入到这个范围，导致两次查询的数据不一致。因为读分为快照读和实时读，

快照读

我们普通的SELECT语句都是普通读，也就是读取的数据都是事务开始时那个状态的数据，普通读的幻读问题主要是通过MVCC来解决的，具体可以看上面的MVCC中的查询操作。

实时读

SELECT *** FOR UPDATE 在查询时会先申请X锁

SELECT ***lock IN SHARE MODE 在查询时会先申请S锁

就是实时读，就是读取的是实时的数据，而不快照数据，读的时候会加Next-Key Lock锁住当前的记录，以及左右两个区间的间隙，这样在读的时候就不能往我们的查询范围插入数据了。


MVCC实现原理


意向锁减小性能开销

关于or查询的真相是：
所谓的索引失效指的是：假如or连接的俩个查询条件字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描。


联合索引是聚集索引吗
什么是覆盖索引


聚集索引是指索引序列与表中行的排列顺序一致,组合索引是指建立在多列上的索引.

索引没有被采用？
1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个 。


哪些情况需要建索引：

主键，唯一索引
经常用作查询条件的字段需要创建索引
经常需要排序、分组和统计的字段需要建立索引
查询中与其他表关联的字段，外键关系建立索引
哪些情况不要建索引？
表的记录太少，百万级以下的数据不需要创建索引

经常增删改的表不需要创建索引

数据重复且分布平均的字段不需要创建索引，如 true,false 之类。

频发更新的字段不适合创建索引

where条件里用不到的字段不需要创建索引


跨库分页查询


内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

在线热备份？


join工作流程

exists是拿外表作为驱动表，外表的数据做循环，每次循环去内表中查询数据，使用适内表比较大的情况

Simple Nested-Loop Join：SNLJ，简单嵌套循环连接 Index Nested-Loop Join：INLJ，索引嵌套循环连接 Block Nested-Loop Join：BNLJ，缓存块嵌套循环连接 在选择Join算法时，会有优先级，理论上会优先判断能否使用INLJ、BNLJ： Index Nested-LoopJoin > Block Nested-Loop Join > Simple Nested-Loop Join

而 join的话正好相反，是那内表作为驱动表，内表的数据做循环，每次循环去外表查询数据，适合内表比较小的情况。

join的实现其实是先从一个表中找出所有行（或者根据where子句查出符号条件的行)，然后去下一个表中循环寻找匹配的行，依次下去，直到找到所有匹配的行，使用join不会去创建临时表，使用in的话会创建临时表，销毁临时表

所以不管是in子查询，exists子查询还是join连接查询，底层的实现原理都是一样的，本质上是没有任何区别的，关键的点在关联表的顺序，如果是join连接查询，MySQL会自动调整表之间的关联顺序，选择最好的一种关联方式。和上面in和exists比较的结论一样，小表驱动大表才是最优的选择方式。

相比于AV树（也就是自平衡的二叉查找树，左右子树高度差不超过1），红黑树插入，删除效率更高。因为不需要保证绝对的平衡，任何不平衡需要的旋转次数不超过3次，即便在最坏的情况下，红黑树能够以O(log(N))的时间复杂度进行搜索、插入、删除操作。

红黑树最长 红黑交替  最短全黑

分库分表 超过1000万

>垂直
根据业务，来对表进行拆分成不同的表，或者根据使用频率，将常用的列分在一个表里面，将不常用的列分在一个表里面。

>水平



检验数据一致性

bin log格式   SBR  RBR    MBR

>慢查询优化

explain+SELECT语句执行，查看结果


索引创建过程
MySQL接受到创建索引的命令后，会进行创建索引

Fast Index Creation
在MySQL 5.5之前创建索引主要是通过

1.创建临时表，表结构是添加索引后的表结构

2.将原表数据导入到临时表

3.删除原表

4.将临时表重命名成原来的表名

Innodb在1.0之后支持Fast Index Creation，就是添加辅助索引（主键以外的索引），不需要重建表，只需要对表加S锁（加锁期间表只能读，不能写），然后创建索引，对主键加索引还是需要重建表。

Online DDL
就是innodb在创建索引时，会将数据库的增删改命令写入缓存日志，创建完毕后通过重放日志来保持数据库的最终一致性。

token会过期吗   有效期

什么是Nested-Loop Join？ 2.Index Nested-Loop Join怎么优化连接？ 3.Block Nested-Loop Join怎么优化连接？


验证码实现   jwt实现


cookie缺点：
数据存储在客户端，存在安全隐患
cookie存储大小、类型存在限制
数据存储在cookie中，如果一次请求cookie过大，会给网络增加更大的开销


char 存储空间浪费
varchar  1个字节存长度  当长度大于255时，使用两个字节来存储长度


索引下推
https://blog.csdn.net/luxiaoruo/article/details/106637231


链接：https://pan.baidu.com/s/1vowXHwoDNfYM8-7hn_HBkw
提取码：java