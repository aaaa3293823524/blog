---
title: 记录不太熟悉的考点
tags:
  - 搭建博客
  - 前端
date: 2021-11-08 22:57:29
abbrlink: 80sm9
---
三次握手  4次挥手https://blog.csdn.net/weixin_33929309/article/details/91629868

最擅长领域  学习经历 
项目看视频   为什么用这个技术  设计 规划   功能实现  场景
协程
hashmap 线程不安全
快恢复     https://blog.csdn.net/qq_36953135/article/details/77506009
2、快恢复   https://blog.csdn.net/jtracydy/article/details/52366461
（1）当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把慢开始门限减半。这是为了预防网络发生拥塞，但不执行慢开始算法。
（2）由于发送方现在认为网络很可能没有发生拥塞（如果网络发生了严重拥塞，就不会一连有好几个报文段连续到达接收方，也就不会导致接收方连续发送重复确认）。因此与慢开始不同之处就是现在不执行慢开始算法（即拥塞窗口现在不设置为1）而是把拥塞窗口的值设置为慢开始门限减半后的值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。

快重传
1、快重传
快重传算法首先要求接收方每收到一个失序的报文段就立即发出重复确认（为的是使发送方及早的知道有报文段没有到达对方）而不要等到自己发送数据时才捎带确认。

快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待为其设置的重传计时器到期。

https过程
内部类    https://www.cnblogs.com/dearcabbage/p/10609838.html
内部类可以分为四种:成员内部类、局部内部类、匿名内部类、静态内部类

局部内部类存在于方法中。
他和成员内部类的区别在于局部内部类的访问权限仅限于方法或作用域内
局部内部类就像局部变量一样，前面不能访问修饰符以及static修饰符

静态内部类和成员内部类相比多了一个static修饰符。它与类的静态成员变量一般，是不依赖于外部类的。同时静态内部类也有它的特殊性。因为外部类加载时只会加载静态域，所以静态内部类不能使用外部类的非静态变量与方法。
同时可以知道成员内部类里面是不能含静态属性或方法的。

静态内部类对象的创建一般是外部类.内部类 类名 = new 外部类.内部类();
成员内部类对象的创建一般是外部类.内部类 类名 = 外部类对象名.new 内部类();

内部类的好处
完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响。
方便写事件驱动程序。


bean生命周期
spring事务传播行为
Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性
事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播
PROPAGATION_

spring事务隔离级别
TransactionDefinition接口中定义了五个表示隔离级别的常量
https://www.cnblogs.com/Jomini/p/14016229.html
循环依赖三重缓存
 Java中的循环依赖分两种，一种是构造器的循环依赖（只能报错），另一种是属性的循环依赖
 Spring解决的循环依赖就是指属性的循环依赖

可以看出这三个map的优先级。其中singletonObjects里面存放的是初始化之后的单例对象；earlySingletonObjects中存放的是一个已完成实例化未完成初始化的早期单例对象；而singletonFactories中存放的是ObjectFactory对象，此对象的getObject方法返回值即刚完成实例化还未开始初始化的单例对象。所以先后顺序是，单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后初始化完成后放入singletonObjects中。
当debug到此处时，以上述Teacher和Student两个循环引用的类为例，如果第一个走到这一步的是Teacher，则从此处这三个map中get到的值都是空，因为还未添加进去。这个方法主要是给循环依赖中后来过来的对象用。

Spring通过将实例化后的对象提前暴露给Spring容器中的singletonFactories，解决了循环依赖的问题

最左前缀匹配  慢查询
https://blog.csdn.net/sinat_41917109/article/details/88944290
最左边开始连续匹配，用到了索引
匹配列前缀
如果左边的列是精确查找的，右边的列可以进行范围查找
drop（删除表） truncate（释放空间） delete（不释放空间）     
https://www.cnblogs.com/zhizhao/p/7825469.html
快排 排序算法时间复杂度 空间复杂度
红黑树

连通分支等图编程  trie 并查集
jvm 三色标记法
白色：没有检查（或者检查过了，确实没有引用指向它了）
灰色：自身被检查了，成员没被检查完（可以认为访问到了，但是正在被检查，就是图的遍历里那些在队列中的节点）
黑色：自身和成员都被检查完了

初始时，所有对象都在 【白色集合】中；
将GC Roots 直接引用到的对象 挪到 【灰色集合】中；
从灰色集合中获取对象：
3.1. 将本对象 引用到的 其他对象 全部挪到 【灰色集合】中；
3.2. 将本对象 挪到 【黑色集合】里面。
重复步骤3，直至【灰色集合】为空时结束。
结束后，仍在【白色集合】的对象即为GC Roots 不可达，可以进行回收。


树状数组 线段树


spring bean生命周期
实例化和属性赋值对应构造方法和setter方法的注入，初始化和销毁是用户能自定义扩展的两个阶段。
>实例化 Instantiation
>属性赋值 Populate
>初始化 Initialization
>销毁 Destruction

单实例在容器启动时创建对象（当然也可以设置懒加载方式，使得单实例也可以在获取时创建）
多实例在每次获取时创建对象

对象的初始化
当对象已经创建完成，并赋好了值，再去调用初始化的方法

对象的销毁
单实例在容器关闭时，容器会自动调用销毁方法
多实例容器不会调用销毁方法，必须用户自定义销毁方法

实例化：Spring 容器根据配置中的 beanDefinition实例化bean。
属性赋值：Spring 使用依赖注入(构造器或者setter)填充所有属性，如 bean 中所定义的配置。
初始化之前： 如果存在bean实现的任何XXXBeanPostProcessors，则调用 postProcessBeforeInitialization() 方法。
初始化：如果为 bean 指定了 init 方法（ 的 init-method 属性），那么将调用它，或者实现了InitializingBean接口，则调用postPropertiesSet()方法实现初始化逻辑。
初始化之后：如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。
销毁：如果为 bean 指定了 destroy 方法（ 的 destroy-method 属性），那么将调用它，或者实现了DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。



CMS：写屏障 + 增量更新  并发标记  重新标记
G1：写屏障 + SATB（原始快照）
ZGC：读屏障

第一种问题： 错标   没什么太大影响 下一轮垃圾回收可解决
第二种问题：漏标，或者叫错杀
错杀的情况只有在 下边两个条件同时发生，才会发生
黑色对象指向了白色对象；
而本来指向这个白色对象的灰色对象断开了对它的连接。

在这讲述解决方案之前，要描述两个名词：读屏障和写屏障。注意，这里的屏障和并发编程中的屏障是两码事儿。这里的屏障很简单，可以理解成就是在读写操作前后插入一段代码，用于记录一些信息、保存某些数据等，概念类似于AOP。

增量更新，就是在赋值操作之前添加一个写屏障，在写屏障中记录新增的引用
在我们这个例子中，在并发标记阶段，A是一个黑色对象，F是一个白色对象，A引用了F，这个引用关系会被记录下来，然后通过这个记录在重新标记阶段再从A对象开始枚举一次，保证如果A还是保持着F的引用，那么F会被正确标记；如果A到F的引用在并发标记阶段又断开了，此次枚举也无法访问到它，活该被清除。

在重新标记阶段如果用户线程还是继续执行，那么这个GC永远可能也做不完了，所以重新标记需要STW，但是这个时间消耗不会太夸张。如果实在重新标记阶段耗时过长，那么可以尝试在重新标记之前做一次Minor GC

原始快照是站在减少引用的对象（也就是例子中的B对象）的角度来解决问题。所谓原始快照，简单的讲，就是在赋值操作（这里是置空）执行之前添加一个写屏障，在写屏障中记录被置空的对象引用。比如，用户线程要执行：B.f=null；那么在写屏障中，首先会把B.f记录下来，然后再进行置空操作。记录下来的这个对象就可以称为原始快照。
那么记录下来之后呢？很简单，之后直接把它变为黑色。意思就是默认认为它不是垃圾，不需要将其清理。当然，这样处理有两种情况，一种情况是，F的确不是垃圾，直到清理的那一刻，都仍然有至少一个引用链能访问到它，这没有什么问题；另一种情况就是F又变成了垃圾。在上述的例子中，就是A到F的引用链也断了，或者直接A都成垃圾了，那F对象就成了浮动垃圾。对于浮动垃圾，前面不止一次就提到了，直接不用理会，如果到下一次GC时它仍然是垃圾，自然会被清理掉。

白色对象可能是从其他对象的引用链上”转移“过来的，也可能就是一个新对象。其实可以想象的到，对于新对象加入到黑色节点，我们无法使用原始快照，但是可以使用增量更新，或者直接简单处理，和并发清理阶段一样：在这期间创建的新对象都认为不是垃圾（比如标记为黑色），如果成了垃圾，那就是浮动垃圾，还是留待下一次GC处理。总之，标记的总体原则就是，“另可放过，不可杀错”
https://blog.csdn.net/huangzhilin2015/article/details/115282572


https://www.jianshu.com/p/14cd2c9d2cd2
对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，常见的对称加密算法有DES、3DES、TDEA、Blowfish、RC5和IDEA。

非对称加密与对称加密相比，其安全性更好
HTTPS为了兼顾安全与效率，同时使用了对称加密和非对称加密。数据是被对称加密传输的，对称加密过程需要客户端的一个密钥，为了确保能把该密钥安全传输到服务器端，采用非对称加密对该密钥进行加密传输，总的来说，对数据进行对称加密，对称加密所要使用的密钥通过非对称加密传输。

验证证书
根证书在验证证书的过程中起着核心的作用
证书的指纹和签名(指纹算法)
指纹的字符串，指纹可以理解为证书身份的唯一代表，是用来保证证书的完整性的，确保证书没有被修改过
签名是在信息后面加上的一段数字串，可以证明该信息有没有被修改过。数字证书在发布的时候，CA机构将证书的指纹和指纹算法通过自己的私钥加密得到的就是证书的签名了

我们在验证证书的时候，首先通过机构的根公钥去解密证书的签名，解密成功的话会得到证书的指纹和指纹算法，指纹是一个hash值，它代表着证书的原始内容，此时再通过指纹算法计算证书内容得到另外一个hash值，如果这两个hash值相同，则代表证书没有被篡改过，否则就是被篡改了

中间人攻击  对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书

time_wait close_wait


线程池状态
running  能够接收新任务，以及对已添加的任务进行处理
shutdown    不接收新任务，但能处理已添加的任务
stop   不接收新任务，不处理已添加的任务，并且会中断正在处理的任务
tyding   所有的任务已终止
terminated   线程池彻底终止，就变成TERMINATED状态


跨域   同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互

JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单适用，兼容性好（兼容低版本IE），缺点是只支持get请求，不支持post请求。

核心思想：网页通过添加一个<script>元素，向服务器请求 JSON 数据，服务器收到请求后，将数据放在一个指定名字的回调函数的参数位置传回来。
CORS 是跨域资源分享
nginx反向代理

restful接口
web攻击

jwt 字符串 hear payload 签名
token  服务端 生成验证 扩展 app 跨域
对于springSecurity的过滤器，我的理解是大致可以分为三类：

1.常规的过滤器，用于对http协议进行支持，如cors,xsrf,headerWrite等，它们通常需要沿着过滤链继续传递;

2.用于认证的过滤器，它们可以根据认证的结果对过滤链进行阻断，如直接返回结果给前端，或者重定向;

3.用于授权的过滤器，它以认证为前提。处于过滤链的末端，通过它之后，将会进入到servlet进行服务;


红黑树的规定   它能够确保任何一个节点的左右子树的高度差不会超过二者中较低那个的一倍

每个节点要么是红色，要么是黑色。
根节点必须是黑色
红色节点不能连续（也即是，红色节点的孩子和父亲都不能是红色）。
对于每个节点，从该点至null（树尾端）的任何路径，都含有相同个数的黑色节点

插入或者删除操作往往会破坏上述条件3或条件4，需要通过调整使得查找树重新满足红黑树的条件
一类是颜色调整，即改变某个节点的颜色；另一类是结构调整，集改变检索树的结构关系。结构调整过程包含两个基本操作：左旋（Rotate Left），右旋（RotateRight）。


设计模式的目的
公司有什么了解

explain 命令

二维数组寻找峰值 O(nlogm)
指针head变

跳跃表  压缩列表 

TCP粘包拆包
happens before
分布式  高并发 微服务

字节序大端小端
大端字节序：高位字节在前，低位字节在后，这是人类读写数值的方法。
小端字节序：低位字节在前，高位字节在后，即以0x1122形式储存。

首先，为什么会有小端字节序？
答案是，计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。
但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。
4.
计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。
如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。
理解这一点，才能理解计算机如何处理字节序。


实现生产者消费者
jvm命令排查

I/O
zookeeper

序列化保证传输完整性

dto  vo
@Resource  和@Autowired

偏向锁  一个线程获取锁
轻量级锁 线程交替执行  不存在锁竞争

JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为Displaced Mark Word。如果一个线程获得锁的时候发现是轻量级锁，会把锁的Mark Word复制到自己的Displaced Mark Word里面。

然后线程尝试用CAS操作将自己线程栈中拷贝的锁记录的地址写入到锁对象的Mark Word中。如果成功，当前线程获得锁，如果失败，表示Mark Word已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，当前线程就尝试使用自旋来获取锁。

自旋（不释放cpu 空操作）

JDK采用了适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋时触发重量级锁的阀值会更高，如果自旋失败了，则自旋的次数就会减少。


当前线程会使用CAS操作将Displaced Mark Word的内容复制回锁的Mark Word里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么CAS操作会失败，此时会释放锁并唤醒被阻塞的线程。(锁释放失败)

重量级锁  操作系统Mutex lock   重量级锁会设置几种状态用来区分请求的线程
阻塞 唤醒开销大
重量级锁就是由对象监视器monitor来实现的，当多个线程同时请求某个重量级锁时，重量级锁会设置几种状态用来区分请求的线程：


锁降级因为如果没有多线程竞争，还是使用重量级锁会造成额外的开销，所以当JVM进入SafePoint安全点（可以简单的认为安全点就是所有用户线程都停止的，只有JVM垃圾回收线程可以执行）的时候，会检查是否有闲置的Monitor，然后试图进行降级。

偏向锁的解锁很简单，其仅仅将线程的栈中的最近一条 lockrecord的 obj字段设置为null

ReentrantLock公平锁和非公平锁

其次是synchronized的等待队列只有一个(调用wait()方法的线程会进入等待队列)，而ReentrantLock可以有多个条件等待队列。

注解可以是作用于源码层面，字节码文件层面，运行时层面。

通常情况下，我们使用的注解都是运行时注解，在运行时，JVM在运行时会针对注解生成一个动态代理类，通过反射获取注解时，实际上返回的是Java运行时生成的动态代理对象$Proxy1，而Proxy类就是我们注解（接口）的具体实现类。

扩容  hashtable(sychronized)  concurrenthashmap(标识节点 到新数组)

>假设原数组长度为16，length-1二进制表示为1111。key1的hash值为9，二进制表示为01001，key2的hash值为25，11001，

所以hash&(length-1)的结果只要看低4位的结果，9和25的低4位都是1001，所以计算结果一致，计算结果都是9，所以在数组中处于数组下标为9的元素链表中。

扩容后数组长度为32，length-1二进制表示为11111，key1的hash值为9，二进制表示为01001，key2的hash值为25，11001，

所以hash&(2*length-1)的结果需要看低5位的结果，9和25的低4位都是1001，所以计算结果不一致，计算结果都是9和25，因为key2的hash值的第五位为1，key1的hash值的第五位为0，所以会多16，也就是原数组长度的大小。

所以原数组同一下标index下的链表存储的hash冲突的元素，扩容后在新数组中的下标newIndex要么为index，要么为index+length（去决定于hash值的第N位为1，还是0，也就是hash&length的结果，原数组长度length为2的N-1次幂）

所以会遍历链表(或者红黑树)，然后对数组下标index下每个节点计算hash&length的结果，然后存放在两个不同的临时链表中，遍历完成后，hash&length结果为0的元素组成的临时链表会存储在新数组index位置，hash&length结果为1的元素组成的临时链表会存储在新数组index+length位置。


>ConcurrentHashMap，HashTable是线程安全的， 在多线程操作时，因为get(key)和containsKey(key)两个操作和在一起不是一个原子性操作，可能在containsKey(key)时发现存在这个键值对，但是get(key)时，有其他线程删除了键值对，导致get(key)返回的Node是null，然后执行方法时抛出异常。所以无法区分value为null还是不存在key。


LinkedHashMap   LRU    before指针 after指针


hashmap链表成环  1.7
扩容头插法


1.8之后
首先迁移时不是拿到一个键值对就迁移一个了，而是对一个数组下标下的链表进行遍历，根据hash值的不同，分成两个链表，然后将两个链表分别设置到新的数组的
下标下。

扩容尾插法

https://blog.csdn.net/jiangjunlanzhoulan/article/details/81239054


concurrenthashmap

atomic原子变量类就是乐观锁

time_wait状态存在的意义是可以有效地终止TCP连接

LockSupport

jdk动态代理
Proxy.newProxyInstance()

创建一个类，继承InvocationHandler，重写invoke()方法，在这个方法里面做一些日志打印的操作后，然后通过反射的API调用method.invoke(target, args);

实现原理：就是在调用Proxy.newProxyInstance()时会根据类加载器和目标类Class对象动态创建一个代理类出来，动态代理类的所有方法的实现都是向下面这样，方法内部都是调用invocationHandler的invoke()方法

cglib动态代理

创建一个类，继承MethodInterceptor类，重写intercept方法，接受方法调用。创建一个Enhancer实例，设置代理类的父类为目标类，设置回调。


树状数组 是一种用于维护前缀信息的的数据结构

Floyd算法 （最短路径）


jquery  bootstrap

油猴脚本
https://blog.csdn.net/u011054333/article/details/104101806


项目遇到问题   项目亮点





JVM
组成：类加载器，运行时数据区，内存分区，执行引擎，本地库接口，
类加载：

双亲委派机制：加载器（应用加载器，扩展加载器，根加载器）
JVM启动过程（JVM的装入环境和配置（查JRE）、装载JVM（LoadJavaVM）、初始化JVM（CreateJavaVM），运行Java程序（GetMainClassName））
JVM内存模型：
本地方法栈：执行本地native方法
虚拟机方法栈:执行java方法（局部变量表、操作数栈、动态连接、方法出口）
程序计数器：字节码的行号
方法区：虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等 1.8之前永生代堆中，之后本地内存元空间
堆
内存溢出泄露：
java编译过程：初始化插入式注解处理器、解析与填充符号表过程、注解处理、分析与字节码生成）


Redis扩容机制


时间复杂度分析


web开发
spring核心：aop（动态代理，切点切面通知）ioc(控制反转 DI)
JDK动态代理和cglib区别：接口   ；底层字节码技术，子类代理（在性能方面，CGLib高很多。但是，CGLib在创建代理对象时所花费的时间多）
spring boot：使用“习惯优于配置”的理念，很容易创建一个能独立运行、准生产级别、基于Spring框架的项目
stater:Spring Boot通过提供众多起步依赖（Starter）降低项目依赖的复杂度
springboot启动流程： 
自动装配：引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数
过程：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类（@Conditional指定的生效条件），实例化类中定义的Bean（组件等），并注入Spring容器
常用注解：@SpringBootApplication（启动类）；@EnableAutoConfiguration（自动配置） @Import @Conditional
@Autowired @Resource 区别：Spring注解，JDK注解； 按类型注入，按名称（也可以按类型）注入； 
bean的作用域：@Scope注解修改Bean的作用域
bean生命周期：实例化 -> 属性赋值 -> 初始化 -> 销毁
解决循环依赖：
  a. 构造器：这种依赖spring是处理不了的，抛出异常。
  b. 单例模式下的setter：通过“三级缓存”处理循环依赖。
  c. 非单例：无法处理。
这三级缓存的作用分别是：
spring管理事务：编程式事务  声明式事务 （@Transactional）
spirng事务传播方式：
spring MVC：
流程：请求 建立连接 前端控制器 请求映射器 请求适配器 ModelAndView 视图解析器 view  渲染返回
注解：@RequestMapping （请求地址映射）@RequestParam（请求参数绑定）@RequestBody：@PathVaribale（绑定url中的占位符）


rehash
switch里面内容


正向代理和反向代理

tomcat类加载   字节码文件剖析

vo dto
https://www.cnblogs.com/zxf330301/p/6534643.html


http缓存


多路io复用

