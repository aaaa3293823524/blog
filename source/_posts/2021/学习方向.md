---
title: 学习方向
tags:
  - 搭建博客
  - 前端
date: 2021-11-02 15:43:15
abbrlink: 80lm7
---
leetcode 65 确定有限状态自动机
struct默认防控属性是public的（只是数据集合 没有对数据操作），而class默认的防控属性是private的
深度（为什么  过程 实现细节 自己设计  适用场景）

buffer（缓冲）是为了提高内存和硬盘（或其他I/0设备）之间的数据交换的速度而设计的。

cache（缓存）是为了提高cpu和内存之间的数据交换速度而设计，也就是平常见到的一级缓存、二级缓存、三级缓存（也叫内存缓存）。

cpu在执行程序所用的指令和读数据都是针对内存的，也就是从内存中取得的。由于内存读写速度慢，为了提高cpu和内存之间数据交换的速度，在cpu和内存之间增加了cache，它的速度比内存快，但是造价高，又由于在cpu内不能集成太多集成电路，所以一般cache比较小，以后intel等公司为了进一步提高速度，又增加了二级cache，甚至三级cache，

缓冲（buffers）是根据磁盘的读写设计的，把分散的写操作集中进行，减少磁盘碎片和硬盘的反复寻道，从而提高系统性能。



static
强软弱虚引用
https工作过程    同一连接2个请求  https://www.cnblogs.com/Sandy-1128/p/http.html

ca证书怎么回事  怎么验证证书有效
session cookie 在哪里（请求体还是哪？）  请求头 https://blog.csdn.net/z9061/article/details/82905874
jwt实现细节 
ping 过程  协议  ICMP
spring  三重缓存   提前暴露  没有循环依赖不暴露-》三重缓存 
select id，a，b，c from where a= and b>  and c<   怎么建索引 sql语句查询过程
(a,b)    那（a，c）可不可以
为什么不用select*
buffer cache   channel
虚拟地址 物理地址  逻辑地址   https://blog.csdn.net/macrossdzh/article/details/5954763
线程池怎么工作的
自己设计线程池

http 6种请求  get post head delete put patch
状态码

自旋锁  可重入锁  https://www.cnblogs.com/theRhyme/p/9133804.html
leetcode:峰值

内部静态类不需要有指向外部类的引用。但非静态内部类需要持有对外部类的引用。
非静态内部类能够访问外部类的静态和非静态成员。静态类不能访问外部类的非静态成员。他只能访问外部类的静态成员

Arrays.binarySearch

207 课程表 210

有限状态自动机、

214 最短回文串   字符串哈希  kmp算法
459  kmp算法

239   滑动窗口最大值

to do list

两个栈实现队列  每次压入元素时将栈中所有元素弹出 压入元素  再将所有元素压入

B树和B+树区别  https://blog.csdn.net/weixin_42228338/article/details/97684517


二叉查找树  
插入  新节点插入到叶子节点
删除（叶子节点 带有1个子节点的节点  带有2个子节点的节点）  https://www.cnblogs.com/lanhaicode/p/11298338.html
带有1个子节点的节点  都是将待删除节点的左/右子树 赋值给 待删除节点的父节点的左/右子树
带有2个子节点的节点
（1）后继节点为子节点   都是将 后继节点 替代 待删除节点，并将待删除节点的左子树 赋值给 后继节点的左子树
（2）后继节点不为子节点  
后继节点无右子节点：
后继节点替换删除节点，
后继节点无右子节点：
后继节点替换删除节点，后继节点右子树变为后继节点父节点左子树

AVL树旋转  https://blog.csdn.net/qq_37934101/article/details/81160254

左旋——自己变为右孩子的左孩子；右旋——自己变为左孩子的右孩子

在插入一个结点后应该沿搜索路径将路径上的结点平衡因子进行修改，当平衡因子大于1时，就需要进行平衡化处理。从发生不平衡的结点起，沿刚才回溯的路径取直接下两层的结点，如果这三个结点在一条直线上，则采用单旋转进行平衡化，如果这三个结点位于一条折线上，则采用双旋转进行平衡化。

先左后右双旋转
当在ptr的左子树的右子树中插入一个结点后，造成了ptr平衡因子为-2的不平衡，将ptr向下找到当前结点的左孩子的右孩子，先进行左单旋ptr->left = subL，然后将ptr的右子树断开指向subR，此时便完成了旋转，最后将平衡因子进行更新。

先右后左双旋转

插入排序
反序对  
冒泡排序
反序表

归并排序是在归并的基础上将数组不断划分成子数组进行排序，从而使整个数组完全有序，该算法是采用了典型的分治法来解决问题，即先将问题分解成子问题，再对子问题的解进行合并从而得到整个问题的解   https://my.oschina.net/joanfen/blog/5008658

说起JWT，我们应该来谈一谈基于token的认证和传统的session认证的区别。  https://www.jianshu.com/p/576dbf44b2ae
但是这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来

基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了

用户使用用户名密码来请求服务器
服务器进行验证用户的信息
服务器通过验证发送给用户一个token
客户端存储token，并在每次请求时附送上这个token值
服务端验证token值，并返回数据

token必须要在每次请求时传递给服务端，它应该保存在请求头里， 另外，服务端要支持CORS(跨来源资源共享)策略，一般我们在服务端这么做就可以了Access-Control-Allow-Origin: *。

JWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串
第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature).
银行家算法

删除链表中重复的结点  
垃圾收集中 工作线程和垃圾收集线程都怎么做的（收集的时候有对象死亡）

事务怎么实现的   https怎么工作的

看书  面经

sql语句优化  查询过程  查询优化器  通常是基于代价估计来做出决定，代价小的先执行
redis数据结构底层

垃圾收集：三色标记法  

>一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1.客户端向服务器发起HTTPS请求，连接到服务器的443端口

2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。

3.服务器将自己的公钥发送给客户端。

4.客户端收到服务器端的证书之后，会对证书进行检查，验证其合法性，如果发现发现证书有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，至此，HTTPS中的第一次HTTP请求结束。

5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。

6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。

7.然后服务器将加密后的密文发送给客户端。

8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。

